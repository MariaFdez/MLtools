}
##Example of data to see how the data is created
noCats <- noDogs <- noLions <- 20
animalsDf <- cats_dogs_lions(noCats, noDogs, noLions, c(4, 150), c(10, 100),
c(20,200),c(1,20), c(2,30), c(5,10), -0.1, 0.8, -0.8)
# illustrating the data
ggplot(data = animalsDf, aes(x = weight, y = height,
colour=Animal, fill=Animal)) +
geom_point() +
xlab("Weight") +
ylab("Height") +
theme_bw(base_size = 14, base_family = "Helvetica")+
scale_color_manual("Animal",
values = c("Cats" = "blue", "Dogs" = "red", "Lions"="green"))
Distances<-matrix(0,nrow(animalsDf),nrow(animalsDf))
for (i in 1:nrow(animalsDf)){
for (j in 1:nrow(animalsDf)){
r <- (animalsDf$weight[i]-animalsDf$weight[j])^2
t <- (animalsDf$height[i]-animalsDf$height[j])^2
Distances[i,j]<-sqrt(r+t)
}
}
View(Distances)
Dist<- as.data.frame(Distances)
neighbors<- matrix(0,nrow(Distances),nrow(Distances))
for (i in 1:nrow(Distances)){
neighbors[i,]<-order(Dist[i,])
}
View(neighbors)
x<-c(0.00,4,5,2,3,4,7,8,9)
sort(x)
order(x)
x<-(Dist[1,])
View(x)
order(x)
x<-(Dist[2,])
order(x)
x<-round((Dist[2,]))
order(x)
x
x<-as.vector(round((Dist[2,])))
x
x<-as.value(round((Dist[2,])))
x<-as.values(round((Dist[2,])))
x<-as.numeric(round((Dist[2,])))
order(x)
x
sort(x)
order(sort(x))
?sort
base::sort(x)
base::order(x)
x<Dist[1,]
x<-Dist[1,]
View(x)
order(x)
x<-Dist[3,]
order(x)
View(Dist)
animalsDf$weight[1]
View(animalsDf)
Distances<-matrix(0,nrow(animalsDf),nrow(animalsDf))
for (i in 1:nrow(animalsDf)){
for (j in 1:nrow(animalsDf)){
r <- (animalsDf$weight[1]-animalsDf$weight[j])^2
t <- (animalsDf$height[i]-animalsDf$height[j])^2
Distances[i,j]<-sqrt(r+t)
}
}
View(Distances)
neighbors<- matrix(0,nrow(Distances),nrow(Distances))
neighbors<- matrix(0,nrow(Distances),nrow(Distances))
for (i in 1:nrow(Distances)){
neighbors[i,]<-order(Distances[i,])
}
View(neighbors)
View(Distances)
x<-Dist[3,]
order(x)
x<-Dist[5,]
order(x)
x<-Dist[,3]
order(x)
# generate means for our mixture
gen2c2dMixture <- function(noObs=c(100, 100), noGaussians=10,
mixtureProb=rep(1/noGaussians, noGaussians),
seed=7851) {
set.seed(seed)
# producing means of our bivariate Gaussians
meansC1 <- rmvnorm(noGaussians, mean = c(1,0), sigma = diag(2))
meansC2 <- rmvnorm(noGaussians, mean = c(0,1), sigma = diag(2))
# for each observation we first randomly select one Gaussian and then
# generate a point according to the parameters of that Gaussian
whichGaussianC1 <- sample(nrow(meansC1), noObs[1],
mixtureProb, replace = TRUE)
whichGaussianC2 <- sample(nrow(meansC2), noObs[2],
mixtureProb, replace = TRUE)
# now drawing samples from selected bivariate Gaussians
drawsC1 <- whichGaussianC1 %>%
sapply(function(x) rmvnorm(1, mean = meansC1[x,],
sigma = diag(2)/5)) %>% t()
drawsC2 <- whichGaussianC2 %>%
sapply(function(x) rmvnorm(1, mean = meansC2[x,],
sigma = diag(2)/5)) %>% t()
# combining and labeling
dataset <- data.frame(rbind(drawsC1, drawsC2),
Y=c(rep("C1", noObs[1]), rep("C2", noObs[2])),
target=c(rep(0, noObs[1]), rep(1, noObs[2])),
stringsAsFactors=FALSE)
return(dataset)
}
dataset <- gen2c2dMixture()
str(dataset)
head(dataset)
# plotting function
plot2dClasses <- function(dataset) {
ggplot(data = dataset, aes(x = X1, y = X2,
colour=Y, fill=Y)) +
geom_point() +
xlab("X1") +
ylab("X2") +
theme_bw(base_size = 14, base_family = "Helvetica") +
scale_color_manual("Y",
values = c("C1" = "blue", "C2" = "red"))
}
plot2dClasses(dataset)
# specify parameters
k <- 1  # odd number
p <- 2  # Manhattan (1), Euclidean (2) or Chebyshev (Inf)
# Compute the distance between each point and all others
noObs <- nrow(dataset)
distMatrix <- matrix(NA, noObs, noObs)
for (obs in 1:noObs) {
# getting the probe for the current observation
probe <- as.numeric(dataset[obs,1:2])
probeExpanded <- matrix(rep(probe, each=noObs), nrow=noObs)
# computing distances between the probe and exemplars in the memory
if (p %in% c(1,2)) {
distMatrix[obs, ] <- ( rowSums((abs(dataset[ ,1:2] -
probeExpanded))^p) )^(1/p)
} else if (p==Inf) {
distMatrix[obs, ] <- apply(abs(dataset[ ,1:2] - probeExpanded), 1, max)
}
}
# Sort the distances in increasing numerical order and pick the first
# k elements
neighbors <- apply(distMatrix, 2, order)
View(neighbors)
View(distMatrix)
View(neighbors)
neighbors <- apply(distMatrix, 1, order)
View(neighbors)
neighbors<- matrix(0,nrow(distMatrix),nrow(distMatrix))
for (i in 1:nrow(distMatrix)){
neighbors[i,]<-order(distMatrix[i,])
}
View(neighbors)
as.numeric(distMatrix[1,])
order(as.numeric(distMatrix[1,]))
order(as.numeric(distMatrix[2,]))
as.numeric(distMatrix[2,])
order(as.numeric(distMatrix[2,]))
order(as.numeric(distMatrix[2,]),decreasing = TRUE)
order(as.numeric(distMatrix[2,]),decreasing = FALSE)
order(round((as.numeric(distMatrix[2,]),3),decreasing = FALSE)
order(round(as.numeric(distMatrix[2,]),3),decreasing = FALSE)
round(as.numeric(distMatrix[2,]),3)
x<- round(as.numeric(distMatrix[2,]),3)-1
x
order(x)
devtools::install_github("MariaFdez/hclass")
library(hclass)
?KNN.k
inputsTest   <- matrix(rnorm(200), ncol=2)
inputsTrain  <- matrix(rnorm(200), ncol=2)
classesTrain <- c(rep(0, 50), rep(1, 50))
# get the kNN predictions for the test set
kNN_classifier(inputsTest, classesTrain, inputsTrain, k=15, obj="predict")
KNN.k(inputsTest, classesTrain, inputsTrain, k=15, obj="predict")
# create small wrapper functions
sigmaXY <- function(rho, sdX, sdY) {
covTerm <- rho * sdX * sdY
VCmatrix <- matrix(c(sdX^2, covTerm, covTerm, sdY^2),
2, 2, byrow = TRUE)
return(VCmatrix)
}
genBVN <- function(n = 1, seed = NA, muXY=c(0,1), sigmaXY=diag(2)) {
if(!is.na(seed)) set.seed(seed)
rdraws <- rmvnorm(n, mean = muXY, sigma = sigmaXY)
return(rdraws)
}
# creating a function that does all the data creating
cats_dogs_lions <- function(noCats, noDogs, noLions, muCats, muDogs, muLions,
sdCats, sdDogs, sdLions, rhoCats, rhoDogs, rhoLions,
seed=1111) {
sigmaCats <- sigmaXY(rho=rhoCats, sdX=sdCats[1], sdY=sdCats[2])
sigmaDogs <- sigmaXY(rho=rhoDogs, sdX=sdDogs[1], sdY=sdDogs[2])
sigmaLions <- sigmaXY(rho=rhoLions, sdX=sdLions[1], sdY=sdLions[2])
cats <- genBVN(noCats, muCats, sigmaCats, seed = seed)
dogs <- genBVN(noDogs, muDogs, sigmaDogs, seed = seed+1)
lions <- genBVN(noLions, muLions, sigmaLions, seed = seed+2)
animalsDf <- as.data.frame(rbind(cats,dogs,lions))
Animal <- c(rep("Cats", noCats), rep("Dogs", noDogs), rep("Lions",noLions))
Animal.ind<-c(rep(1, noCats), rep(2, noDogs), rep(3,noLions))
animalsDf <- cbind(animalsDf, Animal, Animal.ind)
colnames(animalsDf) <- c("weight", "height", "Animal","AnimalIndex")
return(animalsDf)
}
##Example of data to see how the data is created
noCats <- noDogs <- noLions <- 50
animalsDf <- cats_dogs_lions(noCats, noDogs, noLions, c(10, 100), c(15, 100),
c(20,150),c(1,20), c(2,30), c(5,10), -0.1, 0.8, -0.8)
# illustrating the data
ggplot(data = animalsDf, aes(x = weight, y = height,
colour=Animal, fill=Animal)) +
geom_point() +
xlab("Weight") +
ylab("Height") +
theme_bw(base_size = 14, base_family = "Helvetica")+
scale_color_manual("Animal",
values = c("Cats" = "red", "Dogs" = "green", "Lions"="blue"))
# loading in required packages
if (!require("knitr")) install.packages("knitr")
if (!require("rmarkdown")) install.packages("rmarkdown")
if (!require("mvtnorm")) install.packages("mvtnorm")
if (!require("ggplot2")) install.packages("ggplot2")
# create small wrapper functions
sigmaXY <- function(rho, sdX, sdY) {
covTerm <- rho * sdX * sdY
VCmatrix <- matrix(c(sdX^2, covTerm, covTerm, sdY^2),
2, 2, byrow = TRUE)
return(VCmatrix)
}
genBVN <- function(n = 1, seed = NA, muXY=c(0,1), sigmaXY=diag(2)) {
if(!is.na(seed)) set.seed(seed)
rdraws <- rmvnorm(n, mean = muXY, sigma = sigmaXY)
return(rdraws)
}
# creating a function that does all the data creating
cats_dogs_lions <- function(noCats, noDogs, noLions, muCats, muDogs, muLions,
sdCats, sdDogs, sdLions, rhoCats, rhoDogs, rhoLions,
seed=1111) {
sigmaCats <- sigmaXY(rho=rhoCats, sdX=sdCats[1], sdY=sdCats[2])
sigmaDogs <- sigmaXY(rho=rhoDogs, sdX=sdDogs[1], sdY=sdDogs[2])
sigmaLions <- sigmaXY(rho=rhoLions, sdX=sdLions[1], sdY=sdLions[2])
cats <- genBVN(noCats, muCats, sigmaCats, seed = seed)
dogs <- genBVN(noDogs, muDogs, sigmaDogs, seed = seed+1)
lions <- genBVN(noLions, muLions, sigmaLions, seed = seed+2)
animalsDf <- as.data.frame(rbind(cats,dogs,lions))
Animal <- c(rep("Cats", noCats), rep("Dogs", noDogs), rep("Lions",noLions))
Animal.ind<-c(rep(1, noCats), rep(2, noDogs), rep(3,noLions))
animalsDf <- cbind(animalsDf, Animal, Animal.ind)
colnames(animalsDf) <- c("weight", "height", "Animal","AnimalIndex")
return(animalsDf)
}
##Example of data to see how the data is created
noCats <- noDogs <- noLions <- 50
animalsDf <- cats_dogs_lions(noCats, noDogs, noLions, c(10, 100), c(15, 100),
c(20,150),c(1,20), c(2,30), c(5,10), -0.1, 0.8, -0.8)
# illustrating the data
ggplot(data = animalsDf, aes(x = weight, y = height,
colour=Animal, fill=Animal)) +
geom_point() +
xlab("Weight") +
ylab("Height") +
theme_bw(base_size = 14, base_family = "Helvetica")+
scale_color_manual("Animal",
values = c("Cats" = "red", "Dogs" = "green", "Lions"="blue"))
KNN.k(X=animalsDf[,1:2],Y=animalsDf[,3], k=5,obj="train")
x1 <- c(978783,1052488,1039495,1056795,1125545,1536011,1616461,1388507,1608121,1416574,1704919,2653310,2208399,1896304,1957401)
x2 <- c(12645844,12343453,4137266,12229065, 12554668,8856611,12137668,11545424,9253718,8863474,15145969,12793921,14593861,15161586,15785243)
Y <- c(rep("Cats",5),rep("Dogs",5),rep("Lions",5))
X <- as.data.frame(cbind(x1,x2))
Graph.KNN(X=X,Y=Y,k=5)
Graph.KNN(X=,Y=Y,k=5)`
# ----------------------------------------------------------------------
data <- cbind(X,Y)
Graph.KNN(X=data[,1:2],Y=data[,3],k=5)
library(MLtools)
Graph.KNN(X=data[,1:2],Y=data[,3],k=5)
inputsTest   <- matrix(rnorm(200), ncol=2)
inputsTrain  <- matrix(rnorm(200), ncol=2)
classesTrain <- c(rep(0, 50), rep(1, 50))
# get the kNN predictions for the test set
KNN.k(inputsTest, classesTrain, inputsTrain, k=15, obj="predict")
Graph.KNN<- function(X,Y,k){
#take the categories we are working with
realcategories<-unique(Y)
realcategories<-as.character(realcategories)
#take the name of the X's
realcolnames<-colnames(X)
#creating the grid
xlen <- ylen <- 100
X1<-seq(min(X[,1]),max(X[,1]),len=xlen)
X2<-seq(min(X[,2]),max(X[,2]),len=ylen)
data<-matrix(0,(xlen*ylen),2)
colnames(data)<-c(realcolnames[1],realcolnames[2])
is<-1
for (i in 1:xlen){
for (j in 1: ylen){
data[is,]<-c(X1[i],X2[j])
is<-is+1
}
}
##getting the labels for grid points
labels<- MLtools::KNN.k(X=data,Y=Y,k=k,obj="predict",RealData=X)
dataLabel<-cbind(data,labels$predictedClasses)
##diferentiate between point or boundary
Tpoints<-matrix(0,xlen*ylen,4)
plus <- 0
for (i in 1:xlen){
for (j in 2:ylen){
if(dataLabel[(j+plus),3] == dataLabel[(j+plus-1),3]){
Tpoints[(j+plus),4]<-0
Tpoints[(j+plus),1:3]<-as.numeric(dataLabel[(j+plus),1:3])
}else{
Tpoints[(j+plus),4]<-1
Tpoints[(j+plus),1:3]<-as.numeric(dataLabel[(j+plus),1:3])
}
}
plus <- plus + ylen
}
Tpoints<-as.data.frame(Tpoints)
##Changing the animals to it's category name
for(i in 1:nrow(Tpoints)){
if(Tpoints[i,3]==1){
Tpoints[i,3]<-realcategories[1]
}
if(Tpoints[i,3]==2){
Tpoints[i,3] <- realcategories[2]
}
if(Tpoints[i,3]==3){
Tpoints[i,3] <- realcategories[3]
}
}
##Changing the type of point to either Boundary or Point
for(i in 1:nrow(Tpoints)){
if(Tpoints[i,4]==1){
Tpoints[i,4]<-"Boundary"
}
if(Tpoints[i,4]==0){
Tpoints[i,4] <- "Point"
}
}
colnames(Tpoints)<-c(realcolnames[1],realcolnames[2],"category","type")
Tpoints<- Tpoints[Tpoints$category != 0, ]
BouPoints<-Tpoints[Tpoints$type == "Boundary",]
Popoints<-Tpoints[Tpoints$type == "Point",]
TrueData <- cbind(X,Y)
colnames(TrueData)<-c(realcolnames[1],realcolnames[2],"category")
ggplot()+
geom_point(aes(x=BouPoints[,1],y=BouPoints[,2]),data=BouPoints, lwd=1)+
geom_point(aes(x=Popoints[,1],y=Popoints[,2], colour=category),data=Popoints, alpha=1/4, pch=1, lwd=1)+
geom_point(aes(x=TrueData[,1], y=TrueData[,2], colour=category), data=TrueData, pch=18, lwd=3)+
xlab("Weight") +
ylab("Height")
}
Graph.KNN(X=data[,1:2],Y=data[,3],k=5)
library(ggplot2)
Graph.KNN(X=data[,1:2],Y=data[,3],k=5)
X<-data[,1:2]
Y<-data[,3]
k<-5
#take the categories we are working with
realcategories<-unique(Y)
realcategories<-as.character(realcategories)
#take the name of the X's
realcolnames<-colnames(X)
#creating the grid
xlen <- ylen <- 100
X1<-seq(min(X[,1]),max(X[,1]),len=xlen)
X2<-seq(min(X[,2]),max(X[,2]),len=ylen)
data<-matrix(0,(xlen*ylen),2)
colnames(data)<-c(realcolnames[1],realcolnames[2])
is<-1
for (i in 1:xlen){
for (j in 1: ylen){
data[is,]<-c(X1[i],X2[j])
is<-is+1
}
}
##getting the labels for grid points
labels<- MLtools::KNN.k(X=data,Y=Y,k=k,obj="predict",RealData=X)
dataLabel<-cbind(data,labels$predictedClasses)
##diferentiate between point or boundary
Tpoints<-matrix(0,xlen*ylen,4)
plus <- 0
for (i in 1:xlen){
for (j in 2:ylen){
if(dataLabel[(j+plus),3] == dataLabel[(j+plus-1),3]){
Tpoints[(j+plus),4]<-0
Tpoints[(j+plus),1:3]<-as.numeric(dataLabel[(j+plus),1:3])
}else{
Tpoints[(j+plus),4]<-1
Tpoints[(j+plus),1:3]<-as.numeric(dataLabel[(j+plus),1:3])
}
}
plus <- plus + ylen
}
Tpoints<-as.data.frame(Tpoints)
##Changing the animals to it's category name
for(i in 1:nrow(Tpoints)){
if(Tpoints[i,3]==1){
Tpoints[i,3]<-realcategories[1]
}
if(Tpoints[i,3]==2){
Tpoints[i,3] <- realcategories[2]
}
if(Tpoints[i,3]==3){
Tpoints[i,3] <- realcategories[3]
}
}
##Changing the type of point to either Boundary or Point
for(i in 1:nrow(Tpoints)){
if(Tpoints[i,4]==1){
Tpoints[i,4]<-"Boundary"
}
if(Tpoints[i,4]==0){
Tpoints[i,4] <- "Point"
}
}
colnames(Tpoints)<-c(realcolnames[1],realcolnames[2],"category","type")
Tpoints<- Tpoints[Tpoints$category != 0, ]
BouPoints<-Tpoints[Tpoints$type == "Boundary",]
Popoints<-Tpoints[Tpoints$type == "Point",]
TrueData <- cbind(X,Y)
colnames(TrueData)<-c(realcolnames[1],realcolnames[2],"category")
ggplot()+
geom_point(aes(x=BouPoints[,1],y=BouPoints[,2]),data=BouPoints, lwd=1)+
geom_point(aes(x=Popoints[,1],y=Popoints[,2], colour=category),data=Popoints, alpha=1/4, pch=1, lwd=1)+
geom_point(aes(x=TrueData[,1], y=TrueData[,2], colour=category), data=TrueData, pch=18, lwd=3)+
xlab("Weight") +
ylab("Height")
Graph.KNN<- function(X,Y,k){
#take the categories we are working with
realcategories<-unique(Y)
realcategories<-as.character(realcategories)
#take the name of the X's
realcolnames<-colnames(X)
#creating the grid
xlen <- ylen <- 100
X1<-seq(min(X[,1]),max(X[,1]),len=xlen)
X2<-seq(min(X[,2]),max(X[,2]),len=ylen)
data<-matrix(0,(xlen*ylen),2)
colnames(data)<-c(realcolnames[1],realcolnames[2])
is<-1
for (i in 1:xlen){
for (j in 1: ylen){
data[is,]<-c(X1[i],X2[j])
is<-is+1
}
}
##getting the labels for grid points
labels<- MLtools::KNN.k(X=data,Y=Y,k=k,obj="predict",RealData=X)
dataLabel<-cbind(data,labels$predictedClasses)
##diferentiate between point or boundary
Tpoints<-matrix(0,xlen*ylen,4)
plus <- 0
for (i in 1:xlen){
for (j in 2:ylen){
if(dataLabel[(j+plus),3] == dataLabel[(j+plus-1),3]){
Tpoints[(j+plus),4]<-0
Tpoints[(j+plus),1:3]<-as.numeric(dataLabel[(j+plus),1:3])
}else{
Tpoints[(j+plus),4]<-1
Tpoints[(j+plus),1:3]<-as.numeric(dataLabel[(j+plus),1:3])
}
}
plus <- plus + ylen
}
Tpoints<-as.data.frame(Tpoints)
##Changing the animals to it's category name
for(i in 1:nrow(Tpoints)){
if(Tpoints[i,3]==1){
Tpoints[i,3]<-realcategories[1]
}
if(Tpoints[i,3]==2){
Tpoints[i,3] <- realcategories[2]
}
if(Tpoints[i,3]==3){
Tpoints[i,3] <- realcategories[3]
}
}
##Changing the type of point to either Boundary or Point
for(i in 1:nrow(Tpoints)){
if(Tpoints[i,4]==1){
Tpoints[i,4]<-"Boundary"
}
if(Tpoints[i,4]==0){
Tpoints[i,4] <- "Point"
}
}
colnames(Tpoints)<-c(realcolnames[1],realcolnames[2],"category","type")
Tpoints<- Tpoints[Tpoints$category != 0, ]
BouPoints<-Tpoints[Tpoints$type == "Boundary",]
Popoints<-Tpoints[Tpoints$type == "Point",]
TrueData <- cbind(X,Y)
colnames(TrueData)<-c(realcolnames[1],realcolnames[2],"category")
a<-ggplot()+
geom_point(aes(x=BouPoints[,1],y=BouPoints[,2]),data=BouPoints, lwd=1)+
geom_point(aes(x=Popoints[,1],y=Popoints[,2], colour=category),data=Popoints, alpha=1/4, pch=1, lwd=1)+
geom_point(aes(x=TrueData[,1], y=TrueData[,2], colour=category), data=TrueData, pch=18, lwd=3)+
xlab("Weight") +
ylab("Height")
return(a)
}
Graph.KNN(X,Y,k)
devtools::document()
setwd("~/Dropbox/Master/2n term/Machine Learning/MLtools")
devtools::document()
devtools::install_github(MariaFdez/MLtools)
devtools::install_github("MariaFdez/MLtools")
